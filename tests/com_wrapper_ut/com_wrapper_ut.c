// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#include "com_wrapper_ut_pch.h"

#undef ENABLE_MOCKS_DECL
#define ENABLE_MOCKS
#include "umock_c/umock_c_prod.h"

MOCKABLE_FUNCTION(, void*, ut_custom_malloc, size_t, size);
MOCKABLE_FUNCTION(, void, ut_custom_free, void*, ptr);

#undef ENABLE_MOCKS

#include "umock_c/umock_c_prod.h"

static REFIID iid_IUnknown = &IID_IUnknown;
static REFIID iid_ITestInterface = &IID_ITestInterface;
static REFIID iid_ITestInterface2 = &IID_ITestInterface2;
static REFIID iid_ITestInterfaceNotImpl = &IID_ITestInterfaceNotImpl;

typedef TEST_OBJECT_HANDLE TEST_OBJECT_UT_ALLOC_HANDLE;

DECLARE_COM_WRAPPER_OBJECT(TEST_OBJECT_UT_ALLOC_HANDLE, TEST_OBJECT_HANDLE_INTERFACES);
DEFINE_COM_WRAPPER_OBJECT_WITH_MALLOC_FUNCTIONS(TEST_OBJECT_UT_ALLOC_HANDLE, ut_custom_malloc, ut_custom_free, TEST_OBJECT_HANDLE_INTERFACES);

typedef struct TEST_OBJECT_TAG
{
    int dummy;
} TEST_OBJECT;

MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)

static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)
{
    ASSERT_FAIL("umock_c reported error :%" PRI_MU_ENUM "", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));
}

/* Tests_SRS_COM_WRAPPER_01_026: [ COM_WRAPPER_INTERFACE shall ensure that enough entries are in ... to satisfy all functions in the interface. ]*/

/*
// This does not compile, as expected

typedef TEST_OBJECT_HANDLE TEST_OBJECT_NOT_ENOUGH_HANDLE;

#define TEST_OBJECT_NOT_ENOUGH_HANDLE_INTERFACES \
    COM_WRAPPER_INTERFACE(IUnknown, \
        COM_WRAPPER_IUNKNOWN_APIS() \
    ), \
    COM_WRAPPER_INTERFACE(ITestInterface, \
        COM_WRAPPER_IUNKNOWN_APIS(), \
        COM_WRAPPER_FUNCTION_WRAPPER(HRESULT, test_object_2_TestMethodWithReturnNoArgs), \
        COM_WRAPPER_FUNCTION_WRAPPER(void, test_object_2_TestMethodWithoutReturnNoArgs), \
        COM_WRAPPER_FUNCTION_WRAPPER(void, test_object_2_TestMethodWithoutReturnWith2Args, int, a, LPCSTR, b), \
    )

DECLARE_COM_WRAPPER_OBJECT(TEST_OBJECT_NOT_ENOUGH_HANDLE, TEST_OBJECT_NOT_ENOUGH_HANDLE_INTERFACES);
DEFINE_COM_WRAPPER_OBJECT(TEST_OBJECT_NOT_ENOUGH_HANDLE, TEST_OBJECT_NOT_ENOUGH_HANDLE_INTERFACES);
*/

BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)

TEST_SUITE_INITIALIZE(suite_init)
{
    ASSERT_ARE_EQUAL(int, 0, real_gballoc_hl_init(NULL, NULL));

    ASSERT_ARE_EQUAL(int, 0, umock_c_init(on_umock_c_error), "umock_c_init");

    ASSERT_ARE_EQUAL(int, 0, umocktypes_charptr_register_types());

    REGISTER_UMOCK_ALIAS_TYPE(TEST_OBJECT_HANDLE, void*);
    REGISTER_UMOCK_ALIAS_TYPE(TEST_OBJECT_UT_ALLOC_HANDLE, void*);
    REGISTER_UMOCK_ALIAS_TYPE(TEST_OBJECT_UT_ALLOC_HANDLE_DESTROY_FUNC, void*);
    REGISTER_UMOCK_ALIAS_TYPE(HRESULT, long);

    REGISTER_GBALLOC_HL_GLOBAL_MOCK_HOOK();
    REGISTER_TEST_OBJECT_GLOBAL_MOCK_HOOK();
    REGISTER_GLOBAL_MOCK_HOOK(ut_custom_malloc, real_gballoc_hl_malloc);
    REGISTER_GLOBAL_MOCK_HOOK(ut_custom_free, real_gballoc_hl_free);
}

TEST_SUITE_CLEANUP(suite_cleanup)
{
    umock_c_deinit();

    real_gballoc_hl_deinit();
}

TEST_FUNCTION_INITIALIZE(method_init)
{
    umock_c_reset_all_calls();
}

TEST_FUNCTION_CLEANUP(method_cleanup)
{
}

/* COM_WRAPPER_CREATE */

/* Tests_SRS_COM_WRAPPER_01_001: [ DEFINE_COM_WRAPPER_OBJECT shall generate constructors for the COM object for each implemented interface. ]*/
/* Tests_SRS_COM_WRAPPER_01_002: [ COM_WRAPPER_CREATE shall call the COM object constructor generated by DEFINE_COM_WRAPPER_OBJECT. ]*/
/* Tests_SRS_COM_WRAPPER_01_003: [ COM_WRAPPER_CREATE shall allocate enough memory to hold the reference count, the handle wrapped_handle and the implemented COM interface Vtbl pointers. ]*/
/* Tests_SRS_COM_WRAPPER_01_004: [ COM_WRAPPER_CREATE shall store wrapped_handle and wrapped_handle_destroy for future use. ]*/
/* Tests_SRS_COM_WRAPPER_01_005: [ COM_WRAPPER_CREATE shall initialize the reference count of the COM wrapper to 1. ]*/
/* Tests_SRS_COM_WRAPPER_01_006: [ On success COM_WRAPPER_CREATE shall return an interface pointer for returned_interface. ]*/
TEST_FUNCTION(create_succeeds)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));

    // act
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);

    // assert
    ASSERT_IS_NOT_NULL(test_object_ITestInterface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_001: [ DEFINE_COM_WRAPPER_OBJECT shall generate constructors for the COM object for each implemented interface. ]*/
/* Tests_SRS_COM_WRAPPER_01_002: [ COM_WRAPPER_CREATE shall call the COM object constructor generated by DEFINE_COM_WRAPPER_OBJECT. ]*/
/* Tests_SRS_COM_WRAPPER_01_003: [ COM_WRAPPER_CREATE shall allocate enough memory to hold the reference count, the handle wrapped_handle and the implemented COM interface Vtbl pointers. ]*/
/* Tests_SRS_COM_WRAPPER_01_004: [ COM_WRAPPER_CREATE shall store wrapped_handle and wrapped_handle_destroy for future use. ]*/
/* Tests_SRS_COM_WRAPPER_01_005: [ COM_WRAPPER_CREATE shall initialize the reference count of the COM wrapper to 1. ]*/
/* Tests_SRS_COM_WRAPPER_01_006: [ On success COM_WRAPPER_CREATE shall return an interface pointer for returned_interface. ]*/
TEST_FUNCTION(create_for_an_object_with_2_ifs_and_iunknown_succeeds)
{
    // arrange
    TEST_OBJECT_2_HANDLE test_object_2 = test_object_2_create("haga");
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));

    // act
    ITestInterface2* test_object_ITestInterface2 = COM_WRAPPER_CREATE(TEST_OBJECT_2_HANDLE, ITestInterface2, test_object_2, test_object_2_destroy);

    // assert
    ASSERT_IS_NOT_NULL(test_object_ITestInterface2);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface2->lpVtbl->Release(test_object_ITestInterface2);
}

/* Tests_SRS_COM_WRAPPER_01_001: [ DEFINE_COM_WRAPPER_OBJECT shall generate constructors for the COM object for each implemented interface. ]*/
/* Tests_SRS_COM_WRAPPER_01_002: [ COM_WRAPPER_CREATE shall call the COM object constructor generated by DEFINE_COM_WRAPPER_OBJECT. ]*/
/* Tests_SRS_COM_WRAPPER_01_003: [ COM_WRAPPER_CREATE shall allocate enough memory to hold the reference count, the handle wrapped_handle and the implemented COM interface Vtbl pointers. ]*/
/* Tests_SRS_COM_WRAPPER_01_004: [ COM_WRAPPER_CREATE shall store wrapped_handle and wrapped_handle_destroy for future use. ]*/
/* Tests_SRS_COM_WRAPPER_01_005: [ COM_WRAPPER_CREATE shall initialize the reference count of the COM wrapper to 1. ]*/
/* Tests_SRS_COM_WRAPPER_01_006: [ On success COM_WRAPPER_CREATE shall return an interface pointer for returned_interface. ]*/
TEST_FUNCTION(create_for_an_object_with_2_ifs_when_creating_iunknown_succeeds)
{
    // arrange
    TEST_OBJECT_2_HANDLE test_object_2 = test_object_2_create("haga");
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));

    // act
    IUnknown* test_object_IUnknown = COM_WRAPPER_CREATE(TEST_OBJECT_2_HANDLE, IUnknown, test_object_2, test_object_2_destroy);

    // assert
    ASSERT_IS_NOT_NULL(test_object_IUnknown);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_IUnknown->lpVtbl->Release(test_object_IUnknown);
}

/* Tests_SRS_COM_WRAPPER_01_007: [ If any error occurs, COM_WRAPPER_CREATE shall return NULL. ]*/
TEST_FUNCTION(when_malloc_fails_create_fails)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))
        .SetReturn(NULL);

    // act
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);

    // assert
    ASSERT_IS_NULL(test_object_ITestInterface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    test_object_destroy(test_object);
}

/* Tests_SRS_COM_WRAPPER_66_001: [ DEFINE_COM_WRAPPER_OBJECT_WITH_MALLOC_FUNCTIONS shall generate constructors for the COM object for each implemented interface. ]*/
/* Tests_SRS_COM_WRAPPER_66_002: [ DEFINE_COM_WRAPPER_OBJECT_WITH_MALLOC_FUNCTIONS shall generate all the underlying Vtbl structures needed for the COM object. ]*/
/* Tests_SRS_COM_WRAPPER_66_003: [ DEFINE_COM_WRAPPER_OBJECT_WITH_MALLOC_FUNCTIONS shall use malloc_func to allocate memory for the COM wrapper object. ]*/
/* Tests_SRS_COM_WRAPPER_66_004: [ DEFINE_COM_WRAPPER_OBJECT_WITH_MALLOC_FUNCTIONS shall use free_func to free the memory associated with the COM wrapper object. ]*/
TEST_FUNCTION(create_with_custom_allocator_uses_provided_functions)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(ut_custom_malloc(sizeof(TEST_OBJECT_UT_ALLOC_HANDLE_COM_WRAPPER)));

    // act
    ITestInterface* custom_interface = COM_WRAPPER_CREATE(TEST_OBJECT_UT_ALLOC_HANDLE, ITestInterface, (TEST_OBJECT_UT_ALLOC_HANDLE)test_object, test_object_destroy);

    // assert
    ASSERT_IS_NOT_NULL(custom_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // verify free is called on release
    umock_c_reset_all_calls();
    STRICT_EXPECTED_CALL(test_object_destroy(test_object));
    STRICT_EXPECTED_CALL(ut_custom_free(IGNORED_ARG));

    (void)custom_interface->lpVtbl->Release(custom_interface);

    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
}

/* QueryInterface */

/* Tests_SRS_COM_WRAPPER_01_009: [ If This is NULL, QueryInterface shall fail and return E_FAIL. ]*/
TEST_FUNCTION(QueryInterface_with_NULL_This_fails)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ITestInterface* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(NULL, iid_ITestInterface, (void**)&result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, E_FAIL, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_029: [ If riid is NULL, QueryInterface shall fail and return E_POINTER. ]*/
TEST_FUNCTION(QueryInterface_with_NULL_riid_fails)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ITestInterface* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, NULL, &result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, E_POINTER, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_010: [ If ppvObject is NULL, QueryInterface shall fail and return E_POINTER. ]*/
TEST_FUNCTION(QueryInterface_with_NULL_ppvObject_fails)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_ITestInterface, NULL);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, E_POINTER, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_011: [ If riid is one of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall set ppvObject to the interface pointer corresponding to riid and return S_OK. ]*/
TEST_FUNCTION(QueryInterface_with_ITestInterface_succeeds)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ITestInterface* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_ITestInterface, (void**)&result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_IS_NOT_NULL(result_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)result_interface->lpVtbl->Release(result_interface);
}

/* Tests_SRS_COM_WRAPPER_01_011: [ If riid is one of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall set ppvObject to the interface pointer corresponding to riid and return S_OK. ]*/
TEST_FUNCTION(QueryInterface_with_IUnknown_succeeds)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    IUnknown* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_IUnknown, (void**)&result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_IS_NOT_NULL(result_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)result_interface->lpVtbl->Release(result_interface);
}

/* Tests_SRS_COM_WRAPPER_01_011: [ If riid is one of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall set ppvObject to the interface pointer corresponding to riid and return S_OK. ]*/
TEST_FUNCTION(QueryInterface_with_IUnknown_yields_a_usable_IUnknown)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    IUnknown* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_IUnknown, (void**)&result_interface);
    (void)result_interface->lpVtbl->AddRef(result_interface);
    (void)result_interface->lpVtbl->Release(result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_IS_NOT_NULL(result_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)result_interface->lpVtbl->Release(result_interface);
}

/* Tests_SRS_COM_WRAPPER_01_011: [ If riid is one of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall set ppvObject to the interface pointer corresponding to riid and return S_OK. ]*/
TEST_FUNCTION(AddRef_on_IUnknown_allowed_Release_on_ITestInterface)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    IUnknown* result_interface = NULL;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_IUnknown, (void**)&result_interface);
    (void)result_interface->lpVtbl->AddRef(result_interface);
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_IS_NOT_NULL(result_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)result_interface->lpVtbl->Release(result_interface);
}

/* Tests_SRS_COM_WRAPPER_01_011: [ If riid is one of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall set ppvObject to the interface pointer corresponding to riid and return S_OK. ]*/
TEST_FUNCTION(QueryInterface_On_IUnknown_can_get_ITestInterface_again)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    IUnknown* test_object_IUnknown = NULL;
    ITestInterface* result_interface;
    HRESULT result;
    (void)test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_IUnknown, (void**)&test_object_IUnknown);
    umock_c_reset_all_calls();

    // act
    result = test_object_IUnknown->lpVtbl->QueryInterface(test_object_IUnknown, iid_ITestInterface, (void**)&result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_IS_NOT_NULL(result_interface);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)test_object_IUnknown->lpVtbl->Release(test_object_IUnknown);
    (void)result_interface->lpVtbl->Release(result_interface);
}

/* Tests_SRS_COM_WRAPPER_01_012: [ If riid does not match any of the interfaces passed in DEFINE_COM_WRAPPER_OBJECT, QueryInterface shall return E_NOINTERFACE. ]*/
TEST_FUNCTION(QueryInterface_On_An_Interface_that_is_not_implemented_by_the_wrapper_returns_E_NOINTERFACE)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ITestInterfaceNotImpl* result_interface;
    HRESULT result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_ITestInterfaceNotImpl, (void**)&result_interface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, E_NOINTERFACE, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* AddRef */

/* Tests_SRS_COM_WRAPPER_01_013: [ If This is NULL, AddRef shall fail and return 0. ]*/
TEST_FUNCTION(AddRef_with_NULL_returns_0)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ULONG result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->AddRef(NULL);

    // assert
    ASSERT_ARE_EQUAL(ULONG, 0, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_014: [ Otherwise, AddRef shall increment the reference count for the object and return the new reference count. ]*/
TEST_FUNCTION(AddRef_increments_the_reference_count)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ULONG result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->AddRef(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(ULONG, 2, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Release */

/* Tests_SRS_COM_WRAPPER_01_015: [ If This is NULL, Release shall fail and return ULONG_MAX. ]*/
TEST_FUNCTION(Release_with_NULL_This_returns_0)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ULONG result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->Release(NULL);

    // assert
    ASSERT_ARE_EQUAL(ULONG, ULONG_MAX, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_016: [ Otherwise, Release shall decrement the reference count. ]*/
TEST_FUNCTION(Release_decrements_the_reference_count)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    (void)test_object_ITestInterface->lpVtbl->AddRef(test_object_ITestInterface);
    ULONG result;
    umock_c_reset_all_calls();

    // act
    result = test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(ULONG, 1, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_017: [ If the reference count reaches 0: ]*/
/* Tests_SRS_COM_WRAPPER_01_018: [ - Release shall call the destroy function passed in COM_WRAPPER_CREATE. ]*/
/* Tests_SRS_COM_WRAPPER_01_019: [ - Release shall free the memory associated with the COM wrapper. ]*/
TEST_FUNCTION(Release_decrements_the_reference_count_to_zero_and_calls_handle_destroy)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    ULONG result;
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(test_object_destroy(test_object));
    STRICT_EXPECTED_CALL(free(IGNORED_ARG));

    // act
    result = test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(ULONG, 0, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
}

/* COM_WRAPPER_FUNCTION_WRAPPER */

/* Tests_SRS_COM_WRAPPER_01_020: [ The macro shall generate a wrapper function that looks like: ... ]*/
/* Tests_SRS_COM_WRAPPER_01_021: [ If This is NULL, the wrapper shall return without calling the underlying wrapper. ]*/
TEST_FUNCTION(COM_WRAPPER_FUNCTION_WRAPPER_generated_wrapper_with_NULL_This_fails)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    umock_c_reset_all_calls();

    // act
    (void)test_object_ITestInterface->lpVtbl->TestMethodWithReturnNoArgs(NULL);

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_022: [ Otherwise the wrapper shall obtain the handle of the wrapped object. ]*/
/* Tests_SRS_COM_WRAPPER_01_023: [ The wrapper shall call the function wrapped_function_name, while passing the first argument to be the object handle and the rest of the arguments passed to the wrapper. ]*/
/* Tests_SRS_COM_WRAPPER_01_024: [ The wrapper shall return the result of wrapped_function_name. ]*/
TEST_FUNCTION(COM_WRAPPER_FUNCTION_WRAPPER_generates_wrapper_calling_the_underlying_handle_function)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    HRESULT result;
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(test_object_TestMethodWithReturnNoArgs(test_object))
        .SetReturn(S_OK);

    // act
    result = test_object_ITestInterface->lpVtbl->TestMethodWithReturnNoArgs(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, S_OK, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_022: [ Otherwise the wrapper shall obtain the handle of the wrapped object. ]*/
/* Tests_SRS_COM_WRAPPER_01_023: [ The wrapper shall call the function wrapped_function_name, while passing the first argument to be the object handle and the rest of the arguments passed to the wrapper. ]*/
/* Tests_SRS_COM_WRAPPER_01_024: [ The wrapper shall return the result of wrapped_function_name. ]*/
TEST_FUNCTION(COM_WRAPPER_FUNCTION_WRAPPER_generates_wrapper_calling_the_underlying_handle_function_and_returns_its_return_value)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    HRESULT result;
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(test_object_TestMethodWithReturnNoArgs(test_object))
        .SetReturn(E_POINTER);

    // act
    result = test_object_ITestInterface->lpVtbl->TestMethodWithReturnNoArgs(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(HRESULT, E_POINTER, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_022: [ Otherwise the wrapper shall obtain the handle of the wrapped object. ]*/
/* Tests_SRS_COM_WRAPPER_01_023: [ The wrapper shall call the function wrapped_function_name, while passing the first argument to be the object handle and the rest of the arguments passed to the wrapper. ]*/
/* Tests_SRS_COM_WRAPPER_01_024: [ The wrapper shall return the result of wrapped_function_name. ]*/
TEST_FUNCTION(COM_WRAPPER_FUNCTION_WRAPPER_generates_wrapper_calling_the_underlying_handle_function_without_return)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(test_object_TestMethodWithoutReturnNoArgs(test_object));

    // act
    test_object_ITestInterface->lpVtbl->TestMethodWithoutReturnNoArgs(test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_022: [ Otherwise the wrapper shall obtain the handle of the wrapped object. ]*/
/* Tests_SRS_COM_WRAPPER_01_023: [ The wrapper shall call the function wrapped_function_name, while passing the first argument to be the object handle and the rest of the arguments passed to the wrapper. ]*/
/* Tests_SRS_COM_WRAPPER_01_024: [ The wrapper shall return the result of wrapped_function_name. ]*/
TEST_FUNCTION(COM_WRAPPER_FUNCTION_WRAPPER_generates_wrapper_calling_the_underlying_handle_function_and_passing_args)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    umock_c_reset_all_calls();

    STRICT_EXPECTED_CALL(test_object_TestMethodWithoutReturnWith2Args(test_object, 42, "hagauaga"));

    // act
    test_object_ITestInterface->lpVtbl->TestMethodWithoutReturnWith2Args(test_object_ITestInterface, 42, "hagauaga");

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* COM_WRAPPER_GET_WRAPPED_HANDLE */

/* Tests_SRS_COM_WRAPPER_01_030: [ If COM_object is NULL, COM_WRAPPER_GET_WRAPPED_HANDLE shall return NULL. ]*/
TEST_FUNCTION(COM_WRAPPER_GET_WRAPPED_HANDLE_with_NULL_fails)
{
    // arrange

    // act
    TEST_OBJECT_HANDLE result = COM_WRAPPER_GET_WRAPPED_HANDLE(TEST_OBJECT_HANDLE, ITestInterface, NULL);

    // assert
    ASSERT_IS_NULL(result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
}

/* Tests_SRS_COM_WRAPPER_01_031: [ Otherwise, it shall return the handle wrapped by COM_object. ]*/
TEST_FUNCTION(COM_WRAPPER_GET_WRAPPED_HANDLE_succeeds)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    umock_c_reset_all_calls();

    // act
    TEST_OBJECT_HANDLE result = COM_WRAPPER_GET_WRAPPED_HANDLE(TEST_OBJECT_HANDLE, ITestInterface, test_object_ITestInterface);

    // assert
    ASSERT_ARE_EQUAL(void_ptr, test_object, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
}

/* Tests_SRS_COM_WRAPPER_01_031: [ Otherwise, it shall return the handle wrapped by COM_object. ]*/
TEST_FUNCTION(COM_WRAPPER_GET_WRAPPED_HANDLE_succeeds_for_IUnknown_when_object_created_for_ITestInterface)
{
    // arrange
    TEST_OBJECT_HANDLE test_object = test_object_create("haga");
    ITestInterface* test_object_ITestInterface = COM_WRAPPER_CREATE(TEST_OBJECT_HANDLE, ITestInterface, test_object, test_object_destroy);
    IUnknown* test_object_IUnknown;
    ASSERT_ARE_EQUAL(HRESULT, S_OK, (test_object_ITestInterface->lpVtbl->QueryInterface(test_object_ITestInterface, iid_IUnknown, (void**)&test_object_IUnknown)));
    umock_c_reset_all_calls();

    // act
    TEST_OBJECT_HANDLE result = COM_WRAPPER_GET_WRAPPED_HANDLE(TEST_OBJECT_HANDLE, IUnknown, test_object_IUnknown);

    // assert
    ASSERT_ARE_EQUAL(void_ptr, test_object, result);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    (void)test_object_ITestInterface->lpVtbl->Release(test_object_ITestInterface);
    (void)test_object_IUnknown->lpVtbl->Release(test_object_IUnknown);
}

END_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)